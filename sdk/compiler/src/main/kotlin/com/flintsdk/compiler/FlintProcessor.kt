package com.flintsdk.compiler

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import kotlinx.serialization.json.*

class FlintProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor {

    private val codeGenerator = environment.codeGenerator
    private val logger = environment.logger
    private var processed = false

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (processed) return emptyList()

        val hostAnnotation = "com.flintsdk.annotations.FlintToolHost"
        val symbols = resolver.getSymbolsWithAnnotation(hostAnnotation).toList()
        val validSymbols = symbols.filter { it.validate() }
        val deferred = symbols.filter { !it.validate() }

        if (validSymbols.isEmpty()) {
            return deferred
        }

        val allTools = mutableListOf<ToolInfo>()
        val allScreens = mutableSetOf<String>()

        for (symbol in validSymbols) {
            if (symbol !is KSClassDeclaration) {
                logger.error("@FlintToolHost can only be applied to classes", symbol)
                continue
            }

            val tools = extractTools(symbol)
            allTools.addAll(tools)
            allScreens.addAll(tools.map { it.target })

            generateRouter(symbol, tools)
        }

        generateSchemaHolder(allTools, allScreens)
        processed = true
        return emptyList()
    }

    private fun extractTools(classDecl: KSClassDeclaration): List<ToolInfo> {
        val tools = mutableListOf<ToolInfo>()
        val toolAnnotation = "com.flintsdk.annotations.FlintTool"

        for (function in classDecl.getAllFunctions()) {
            val toolAnno = function.annotations.firstOrNull {
                it.annotationType.resolve().declaration.qualifiedName?.asString() == toolAnnotation
            } ?: continue

            val name = toolAnno.arguments.first { it.name?.asString() == "name" }.value as String
            val description = toolAnno.arguments.first { it.name?.asString() == "description" }.value as String
            val target = toolAnno.arguments.first { it.name?.asString() == "target" }.value as String

            val params = extractParams(function)

            // Validate unique tool names
            if (tools.any { it.name == name }) {
                logger.error("Duplicate tool name: $name", function)
                continue
            }

            tools.add(ToolInfo(name, description, target, function.simpleName.asString(), params))
        }

        return tools
    }

    private fun extractParams(function: KSFunctionDeclaration): List<ParamInfo> {
        val paramAnnotation = "com.flintsdk.annotations.FlintParam"
        val params = mutableListOf<ParamInfo>()

        for (param in function.parameters) {
            val paramAnno = param.annotations.firstOrNull {
                it.annotationType.resolve().declaration.qualifiedName?.asString() == paramAnnotation
            } ?: continue

            val description = paramAnno.arguments.first { it.name?.asString() == "description" }.value as String
            val customName = paramAnno.arguments.firstOrNull { it.name?.asString() == "name" }?.value as? String ?: ""

            val kotlinName = param.name?.asString() ?: continue
            val schemaName = if (customName.isNotEmpty()) customName else camelToSnakeCase(kotlinName)
            val typeName = param.type.resolve().declaration.qualifiedName?.asString() ?: "kotlin.String"
            val hasDefault = param.hasDefault

            // Check for List<String>
            val fullTypeName = if (typeName == "kotlin.collections.List") {
                val typeArg = param.type.resolve().arguments.firstOrNull()
                    ?.type?.resolve()?.declaration?.qualifiedName?.asString()
                if (typeArg == "kotlin.String") "kotlin.collections.List<kotlin.String>" else typeName
            } else {
                typeName
            }

            // Validate type
            try {
                kotlinTypeToJsonSchema(fullTypeName)
            } catch (e: IllegalArgumentException) {
                logger.error("Unsupported parameter type '$fullTypeName' for param '$kotlinName'", param)
                continue
            }

            params.add(ParamInfo(kotlinName, schemaName, fullTypeName, description, hasDefault))
        }

        return params
    }

    private fun generateRouter(classDecl: KSClassDeclaration, tools: List<ToolInfo>) {
        val packageName = classDecl.packageName.asString()
        val hostClassName = classDecl.simpleName.asString()
        val routerClassName = "FlintRouter_$hostClassName"

        val file = codeGenerator.createNewFile(
            Dependencies(true, classDecl.containingFile!!),
            packageName,
            routerClassName
        )

        val code = buildString {
            appendLine("// AUTO-GENERATED by Flint KSP Processor — do not edit")
            appendLine("package $packageName")
            appendLine()
            appendLine("import com.flintsdk.annotations.FlintToolHandler")
            appendLine()
            appendLine("class $routerClassName(private val host: $hostClassName) : FlintToolHandler {")
            appendLine("    override fun onToolCall(name: String, params: Map<String, Any?>): Map<String, Any?>? {")
            appendLine("        return when (name) {")

            for (tool in tools) {
                appendLine("            \"${tool.name}\" -> {")

                // Build parameter extraction
                val paramCalls = tool.params.map { param ->
                    val extractor = kotlinTypeToExtractor(param.typeName, param.schemaName, param.hasDefault)
                    "                    ${param.kotlinName} = $extractor"
                }

                if (paramCalls.isNotEmpty()) {
                    appendLine("                host.${tool.functionName}(")
                    appendLine(paramCalls.joinToString(",\n"))
                    appendLine("                )")
                } else {
                    appendLine("                host.${tool.functionName}()")
                }

                appendLine("                mapOf(\"_target\" to \"${tool.target}\")")
                appendLine("            }")
            }

            appendLine("            else -> null")
            appendLine("        }")
            appendLine("    }")
            appendLine("}")
        }

        file.write(code.toByteArray())
        file.close()
    }

    private fun generateSchemaHolder(tools: List<ToolInfo>, screens: Set<String>) {
        val json = buildJsonObject {
            put("protocol", "flint")
            put("version", "1.0")
            putJsonArray("tools") {
                for (tool in tools) {
                    addJsonObject {
                        put("name", tool.name)
                        put("description", tool.description)
                        put("target", tool.target)
                        putJsonObject("inputSchema") {
                            put("type", "object")
                            putJsonObject("properties") {
                                for (param in tool.params) {
                                    putJsonObject(param.schemaName) {
                                        val (jsonType, extra) = kotlinTypeToJsonSchema(param.typeName)
                                        put("type", jsonType)
                                        put("description", param.description)
                                        if (extra != null) {
                                            for ((k, v) in extra) {
                                                @Suppress("UNCHECKED_CAST")
                                                when (v) {
                                                    is Map<*, *> -> putJsonObject(k) {
                                                        for ((ik, iv) in v as Map<String, String>) {
                                                            put(ik, iv)
                                                        }
                                                    }
                                                    is String -> put(k, v)
                                                    else -> {}
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            putJsonArray("required") {
                                for (param in tool.params.filter { !it.hasDefault }) {
                                    add(param.schemaName)
                                }
                            }
                        }
                    }
                }
            }
            putJsonArray("screens") {
                for (screen in screens.sorted()) {
                    add(screen)
                }
            }
        }

        val prettyJson = Json { prettyPrint = true }.encodeToString(JsonObject.serializer(), json)

        val file = codeGenerator.createNewFile(
            Dependencies.ALL_FILES,
            "com.flintsdk.generated",
            "FlintSchemaHolder"
        )

        val code = buildString {
            appendLine("// AUTO-GENERATED by Flint KSP Processor — do not edit")
            appendLine("package com.flintsdk.generated")
            appendLine()
            appendLine("object FlintSchemaHolder {")
            appendLine("    @JvmField val JSON: String = \"\"\"")
            appendLine(prettyJson)
            appendLine("    \"\"\".trimIndent()")
            appendLine("}")
        }

        file.write(code.toByteArray())
        file.close()
    }
}

data class ToolInfo(
    val name: String,
    val description: String,
    val target: String,
    val functionName: String,
    val params: List<ParamInfo>
)

data class ParamInfo(
    val kotlinName: String,
    val schemaName: String,
    val typeName: String,
    val description: String,
    val hasDefault: Boolean
)

class FlintProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return FlintProcessor(environment)
    }
}
