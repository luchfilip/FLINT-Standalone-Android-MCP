# Android Capability Protocol (Flint) — Full Spec v1.0

---

## What Is Flint

Flint lets AI agents control Android apps through a single hub. Apps don't run MCP servers. Apps don't know MCP exists. They add a small SDK, annotate their code, and become AI-controllable.

Three layers:

1. **Tools** — entry points that navigate the app (search, open playlist, go home)
2. **Screens** — the app tells the Hub what screen is currently showing
3. **Semantic UI** — annotated composables that make the screen machine-readable

The Hub discovers all Flint-enabled apps, reads their capabilities from a static JSON (generated at build time), and exposes everything through one MCP server. The LLM orchestrates: call a tool to navigate, read the screen to understand what's there, use accessibility or annotated actions to interact.

---

## Part 1: The Hub App (Stage 1)

A single APK. No desktop. No ADB. No Termux.

- **Foreground Service** running an HTTP/SSE MCP server (Ktor embedded)
- **AccessibilityService** for universal screen reading and gesture dispatch
- **NotificationListenerService** for notification access
- Built-in device tools: screenshot, tap, swipe, type, SMS, call, contacts, app launch, settings

The Hub works with ANY app via accessibility — no SDK needed. Flint-enabled apps just get a much richer, faster, more structured experience.

### Built-in MCP Tools

```
device.screenshot        — capture current screen
device.get_tree          — accessibility tree of current screen
device.tap               — tap at coordinates
device.long_press        — long press at coordinates
device.swipe             — swipe gesture
device.type              — input text into focused field
device.press_key         — back, home, recents, volume
device.scroll            — scroll up/down/left/right

sms.send                 — send SMS
sms.read                 — read inbox
call.dial                — place a call
call.answer              — answer incoming call
contacts.search          — search contacts
contacts.create          — add contact

notifications.list       — list active notifications
notifications.dismiss    — dismiss a notification
notifications.tap        — open a notification
notifications.reply      — reply to a notification (direct reply)

apps.list                — list installed apps
apps.launch              — launch an app
apps.close               — force stop an app
system.battery           — battery status
system.wifi              — toggle wifi
system.bluetooth         — toggle bluetooth
system.volume            — get/set volume
clipboard.get            — read clipboard
clipboard.set            — write clipboard
```

### For Flint-enabled Apps, Additional Tools Appear

```
musicapp.search          — search for tracks (global tool from Flint)
musicapp.open_playlist   — open a playlist (global tool from Flint)
musicapp.read_screen     — get structured screen snapshot (semantic tree)
musicapp.action          — invoke an annotated action on a UI element
```

---

## Part 2: Flint SDK Integration (Stage 2)

### Developer Setup

```kotlin
// build.gradle.kts
plugins {
    id("com.flintsdk") version "1.0.0"
}

dependencies {
    implementation("com.flintsdk:runtime:1.0.0")
    ksp("com.flintsdk:compiler:1.0.0")
}
```

### Initialization

```kotlin
@HiltAndroidApp
class MyApp : Application() {

    @Inject lateinit var musicTools: MusicTools

    override fun onCreate() {
        super.onCreate()
        Flint.init(this)  // captures applicationContext, registers ContentProvider
        Flint.add(FlintRouter_MusicTools(musicTools))  // generated by KSP
    }
}
```

`Flint.init(context)` is called once. Captures `applicationContext` as a singleton. From then on, `Flint.add()` can be called from anywhere — Hilt modules, feature modules, dynamic feature modules, wherever.

```kotlin
// From anywhere in the app, anytime
Flint.add(FlintRouter_PlaylistTools(playlistTools))
Flint.add(FlintRouter_SettingsTools(settingsTools))
```

### The Flint Singleton

```kotlin
object Flint {
    lateinit var context: Context
        private set

    internal var currentScreen: String? = null
        private set

    private val handlers = mutableListOf<FlintToolHandler>()

    fun init(context: Context) {
        this.context = context.applicationContext
    }

    fun add(handler: FlintToolHandler) {
        handlers.add(handler)
    }

    // Composable — tracks current screen
    @Composable
    fun screen(name: String) {
        DisposableEffect(name) {
            currentScreen = name
            onDispose {
                if (currentScreen == name) currentScreen = null
            }
        }
    }

    // Internal — routes tool calls from Hub
    internal fun routeTool(name: String, params: Bundle): Bundle {
        for (handler in handlers) {
            val result = handler.onToolCall(name, params)
            if (result != null) return result
        }
        return bundleOf("_error" to "unknown tool: $name")
    }
}
```

---

## Part 3: Tools (Global Entry Points)

Tools are methods on a handler class. They navigate the app and return the screen key where the app landed. The developer uses their own navigator — Compose Navigation, custom routing, Intent deep links, whatever they have.

### Defining Tools

```kotlin
@FlintToolHost
class MusicTools @Inject constructor(
    private val navigator: AppNavigator
) {

    @FlintTool(
        name = "search",
        description = "Search for tracks. Opens search results screen.",
        target = "search_results"
    )
    fun search(
        @FlintParam(description = "Search query") query: String
    ) {
        navigator.navigate("search/$query")
    }

    @FlintTool(
        name = "open_playlist",
        description = "Open a playlist by ID.",
        target = "playlist_detail"
    )
    fun openPlaylist(
        @FlintParam(description = "Playlist ID") playlistId: String
    ) {
        navigator.navigate("playlist/$playlistId")
    }

    @FlintTool(
        name = "go_home",
        description = "Navigate to home screen.",
        target = "home"
    )
    fun goHome() {
        navigator.navigate("home")
    }
}
```

Things to note:

- Functions return `void`. They just navigate.
- `target` tells the Hub which screen to expect after this tool is called.
- The developer's navigation code is their own — the SDK doesn't interfere.
- `@FlintParam` description enables KSP to generate the inputSchema.
- KSP infers `required` from Kotlin default values. No default = required.
- KSP infers JSON Schema type from Kotlin type.

### Annotations

```kotlin
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class FlintToolHost

@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class FlintTool(
    val name: String,
    val description: String,
    val target: String           // screen key where this tool navigates to
)

@Target(AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
annotation class FlintParam(
    val description: String,
    val name: String = ""        // override param name in schema, default: auto snake_case from Kotlin name
)
```

### KSP-Generated Code

From the annotations above, KSP generates two things:

**1. `res/raw/flint.json`** — static capability manifest, readable without launching the app:

```json
{
  "protocol": "flint",
  "version": "1.0",
  "name": "MusicApp",
  "tools": [
    {
      "name": "search",
      "description": "Search for tracks. Opens search results screen.",
      "target": "search_results",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Search query"
          }
        },
        "required": ["query"]
      }
    },
    {
      "name": "open_playlist",
      "description": "Open a playlist by ID.",
      "target": "playlist_detail",
      "inputSchema": {
        "type": "object",
        "properties": {
          "playlist_id": {
            "type": "string",
            "description": "Playlist ID"
          }
        },
        "required": ["playlist_id"]
      }
    },
    {
      "name": "go_home",
      "description": "Navigate to home screen.",
      "target": "home",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    }
  ],
  "screens": ["home", "search_results", "playlist_detail", "track_detail"]
}
```

**2. `FlintRouter_MusicTools`** — routes tool calls to the annotated methods:

```kotlin
// AUTO-GENERATED — do not edit
class FlintRouter_MusicTools(private val host: MusicTools) : FlintToolHandler {
    override fun onToolCall(name: String, params: Bundle): Bundle? {
        return when (name) {
            "search" -> {
                host.search(query = params.getString("query")!!)
                bundleOf("_target" to "search_results")
            }
            "open_playlist" -> {
                host.openPlaylist(playlistId = params.getString("playlist_id")!!)
                bundleOf("_target" to "playlist_detail")
            }
            "go_home" -> {
                host.goHome()
                bundleOf("_target" to "home")
            }
            else -> null  // not handled by this router, try next
        }
    }
}
```

### Type Mapping

KSP converts Kotlin types to JSON Schema:

| Kotlin Type | JSON Schema | Bundle Read |
|---|---|---|
| `String` | `"string"` | `getString(key)!!` |
| `String` with default | `"string"`, not required | `getString(key) ?: default` |
| `Int` | `"integer"` | `getInt(key, default)` |
| `Long` | `"integer"` | `getLong(key, default)` |
| `Double` | `"number"` | `getDouble(key, default)` |
| `Float` | `"number"` | `getFloat(key, default)` |
| `Boolean` | `"boolean"` | `getBoolean(key, default)` |
| `List<String>` | `"array"` of `"string"` | `getStringArrayList(key)` |

Complex objects: pass as JSON string, developer parses.

---

## Part 4: Screen Tracking

Each composable screen registers its name with the SDK. One line.

```kotlin
@Composable
fun SearchResultsScreen(query: String) {
    Flint.screen("search_results")
    // ... normal UI
}

@Composable
fun TrackDetailScreen(trackId: String) {
    Flint.screen("track_detail")
    // ... normal UI
}

@Composable
fun PlaylistDetailScreen(playlistId: String) {
    Flint.screen("playlist_detail")
    // ... normal UI
}

@Composable
fun HomeScreen() {
    Flint.screen("home")
    // ... normal UI
}
```

`Flint.screen()` is a `@Composable` function. It sets the current screen on enter, clears on dispose. The Hub polls this to confirm navigation landed where expected.

### Hub Verification Flow

After calling a tool:

```
Hub: calls musicapp.search({ query: "bohemian rhapsody" })
     tool returns target = "search_results"

Hub: polls get_current_screen every ~100ms for up to 2s
     waiting for currentScreen == "search_results"

App: Compose navigates, SearchResultsScreen renders
     Flint.screen("search_results") fires
     currentScreen = "search_results"

Hub: confirmed. proceeds to read screen.
```

If the screen doesn't match within the timeout, the Hub reports the tool may have failed or navigated somewhere unexpected. The LLM can screenshot to investigate.

---

## Part 5: Semantic UI (Making Screens Machine-Readable)

This is the core innovation. Developers annotate their existing Compose UI with Modifier extensions. These build on Compose's `Modifier.semantics {}` system — the same system that powers Android accessibility. The annotations make the UI structured and queryable for AI agents while simultaneously improving accessibility for users with disabilities.

### Available Modifiers

#### `flintContent(key: String)` — Label a piece of data

Marks a composable as containing a named value. The Hub reads the rendered text.

```kotlin
Text(
    text = track.title,
    modifier = Modifier.flintContent("title")
)

Text(
    text = track.artist,
    modifier = Modifier.flintContent("artist")
)

Text(
    text = "${track.duration}",
    modifier = Modifier.flintContent("duration")
)
```

#### `flintList(id: String, description: String)` — Mark a scrollable list

Marks a LazyColumn/LazyRow/etc as a list container. Child items are indexed automatically.

```kotlin
LazyColumn(
    modifier = Modifier.flintList("results", description = "Search results for songs")
) {
    itemsIndexed(results) { index, track ->
        TrackRow(track, index)
    }
}
```

#### `flintItem(index: Int)` — Mark a list item

Marks a composable as an item within an `flintList`. The index matches the list position.

```kotlin
Row(
    modifier = Modifier.flintItem(index)
) {
    // ...
}
```

#### `flintAction(name: String, description: String)` — Mark an interactive element

Tells the Hub this element can be tapped/invoked by name, not just by coordinates.

```kotlin
Row(
    modifier = Modifier
        .flintItem(index)
        .flintAction("select", "Select this track")
        .clickable { onTrackClick(track) }
) {
    // ...
}

IconButton(
    onClick = { viewModel.toggleFavorite(track) },
    modifier = Modifier.flintAction("favorite", "Toggle favorite")
) {
    Icon(Icons.Default.Favorite, contentDescription = "Favorite")
}
```

#### `flintOverlay(id: String, description: String)` — Mark overlays

Marks a composable as an overlay — bottom sheets, dialogs, mini players, snackbars. These are part of the current screen but rendered above the main content.

```kotlin
// Persistent mini player
MiniPlayer(
    modifier = Modifier.flintOverlay("player_mini", "Mini player with current track")
)

// Dialog
AlertDialog(
    modifier = Modifier.flintOverlay("confirm_delete", "Confirm delete dialog"),
    // ...
)

// Bottom sheet
ModalBottomSheet(
    modifier = Modifier.flintOverlay("add_to_playlist", "Choose a playlist"),
    // ...
) {
    // ...
}
```

### Modifier Implementations

All modifiers are thin wrappers on Compose's built-in semantics system:

```kotlin
object FlintSemantic {
    val ContentKey = SemanticsPropertyKey<String>("FlintContentKey")
    val ListId = SemanticsPropertyKey<String>("FlintListId")
    val ListDescription = SemanticsPropertyKey<String>("FlintListDescription")
    val ItemIndex = SemanticsPropertyKey<Int>("FlintItemIndex")
    val ActionName = SemanticsPropertyKey<String>("FlintActionName")
    val ActionDescription = SemanticsPropertyKey<String>("FlintActionDescription")
    val OverlayId = SemanticsPropertyKey<String>("FlintOverlayId")
    val OverlayDescription = SemanticsPropertyKey<String>("FlintOverlayDescription")
}

fun Modifier.flintContent(key: String) = this.semantics {
    set(FlintSemantic.ContentKey, key)
}

fun Modifier.flintList(id: String, description: String = "") = this.semantics {
    set(FlintSemantic.ListId, id)
    set(FlintSemantic.ListDescription, description)
}

fun Modifier.flintItem(index: Int) = this.semantics {
    set(FlintSemantic.ItemIndex, index)
}

fun Modifier.flintAction(name: String, description: String = "") = this.semantics {
    set(FlintSemantic.ActionName, name)
    set(FlintSemantic.ActionDescription, description)
}

fun Modifier.flintOverlay(id: String, description: String = "") = this.semantics {
    set(FlintSemantic.OverlayId, id)
    set(FlintSemantic.OverlayDescription, description)
}
```

Because these use `Modifier.semantics`, they automatically enrich the Android accessibility tree. Screen readers, testing frameworks, and Flint all benefit from the same annotations.

### Screen Snapshots

When the Hub calls `read_screen`, the SDK walks the semantic tree inside the app process and returns a structured snapshot:

```json
{
  "screen": "search_results",
  "content": {
    "elements": [
      {
        "type": "list",
        "id": "results",
        "description": "Search results for songs",
        "items": [
          {
            "index": 0,
            "content": {
              "title": "Bohemian Rhapsody",
              "artist": "Queen",
              "duration": "5:55"
            },
            "actions": [
              { "name": "select", "description": "Select this track" },
              { "name": "favorite", "description": "Toggle favorite" }
            ]
          },
          {
            "index": 1,
            "content": {
              "title": "Bohemian Like You",
              "artist": "The Dandy Warhols",
              "duration": "3:32"
            },
            "actions": [
              { "name": "select", "description": "Select this track" },
              { "name": "favorite", "description": "Toggle favorite" }
            ]
          }
        ]
      }
    ]
  },
  "overlays": [
    {
      "id": "player_mini",
      "description": "Mini player with current track",
      "content": {
        "title": "Yesterday",
        "artist": "The Beatles"
      },
      "actions": [
        { "name": "play_pause", "description": "Play or pause" },
        { "name": "next", "description": "Next track" }
      ]
    }
  ]
}
```

Non-Flint apps: the Hub falls back to the raw accessibility tree from the AccessibilityService. It still works — just less structured.

### Two Ways to Interact After Reading

**Accessibility (always works, no extra dev effort):**
The Hub uses its AccessibilityService to tap at the coordinates of the element. The semantic tree includes bounds for every node. This works for any app, annotated or not.

**Annotated actions (faster, more reliable, needs `flintAction`):**
The Hub calls an action by name on a specific element through the ContentProvider. The SDK finds the semantic node with that action and programmatically triggers the click action on it. No coordinates, doesn't break if layout shifts.

```
Hub: invoke action "select" on list "results" item 0

SDK internally:
  1. Find semantic node: listId="results" → itemIndex=0 → actionName="select"
  2. Get the Compose node behind it
  3. Trigger performAction(ACTION_CLICK) or invoke the click lambda
  4. Return success
```

The LLM doesn't need to know which path is used. The Hub picks the best available method.

---

## Part 6: ContentProvider Communication

The SDK registers a ContentProvider (auto-merged into the app's manifest). The Hub communicates entirely through `contentResolver.call()` — synchronous, Bundle in, Bundle out.

### Provider Methods

| Method | Arg | Extras | Returns |
|---|---|---|---|
| `get_schema` | — | — | `{ schema: "...json string..." }` |
| `get_screen` | — | — | `{ screen: "search_results" }` or `{ screen: null }` |
| `read_screen` | — | — | `{ snapshot: "...json string..." }` (the full semantic tree snapshot) |
| `call_tool` | tool name | params Bundle | `{ _target: "screen_key" }` or `{ _error: "..." }` |
| `invoke_action` | action name | `{ list: "results", index: 0 }` | `{ _success: true }` or `{ _error: "..." }` |

### Provider Implementation (Inside SDK)

```kotlin
class FlintProvider : ContentProvider() {

    override fun call(method: String, arg: String?, extras: Bundle?): Bundle? {
        return when (method) {
            "get_schema" -> {
                val json = context!!.resources.openRawResource(R.raw.flint)
                    .bufferedReader().readText()
                bundleOf("schema" to json)
            }
            "get_screen" -> {
                bundleOf("screen" to Flint.currentScreen)
            }
            "read_screen" -> {
                val snapshot = FlintTreeWalker.readCurrentScreen(context!!)
                bundleOf("snapshot" to snapshot.toJson())
            }
            "call_tool" -> {
                val toolName = arg ?: return bundleOf("_error" to "missing tool name")
                Flint.routeTool(toolName, extras ?: Bundle.EMPTY)
            }
            "invoke_action" -> {
                val actionName = arg ?: return bundleOf("_error" to "missing action name")
                FlintActionInvoker.invoke(context!!, actionName, extras ?: Bundle.EMPTY)
            }
            else -> bundleOf("_error" to "unknown method")
        }
    }

    override fun onCreate() = true
    override fun query(u: Uri, p: Array<String>?, s: String?, a: Array<String>?, o: String?) = null
    override fun getType(uri: Uri) = null
    override fun insert(uri: Uri, values: ContentValues?) = null
    override fun delete(uri: Uri, s: String?, a: Array<String>?) = 0
    override fun update(uri: Uri, v: ContentValues?, s: String?, a: Array<String>?) = 0
}
```

### Auto-merged Manifest Entry

```xml
<!-- Inside SDK's AndroidManifest.xml — merged automatically -->
<provider
    android:name="com.flintsdk.FlintProvider"
    android:authorities="${applicationId}.flint"
    android:exported="true" />
```

The Hub discovers providers via:

```kotlin
val intent = Intent("com.flintsdk.DISCOVER")
val providers = packageManager.queryIntentContentProviders(intent, 0)
```

---

## Part 7: Hub Discovery & MCP Translation

### App Discovery

The Hub scans installed apps on boot and when apps are installed/updated/removed:

```kotlin
class FlintScanner(private val context: Context) {

    fun discoverApps(): List<FlintApp> {
        val pm = context.packageManager
        val apps = pm.getInstalledApplications(PackageManager.GET_META_DATA)

        return apps.mapNotNull { appInfo ->
            // Check for Flint ContentProvider
            val authority = "${appInfo.packageName}.flint"
            val providerInfo = try {
                pm.resolveContentProvider(authority, 0)
            } catch (e: Exception) { null }

            providerInfo ?: return@mapNotNull null

            // Read static schema without launching the app
            // Uses createPackageContext to read res/raw/flint.json
            val appContext = context.createPackageContext(
                appInfo.packageName,
                Context.CONTEXT_RESTRICTED
            )
            val resId = appContext.resources.getIdentifier("flint", "raw", appInfo.packageName)
            if (resId == 0) return@mapNotNull null

            val schemaJson = appContext.resources.openRawResource(resId)
                .bufferedReader().readText()

            FlintApp(
                packageName = appInfo.packageName,
                appLabel = pm.getApplicationLabel(appInfo).toString(),
                authority = authority,
                schema = Json.decodeFromString(schemaJson)
            )
        }
    }
}
```

### MCP Tool Translation

Each Flint app's tools get namespaced and exposed through the Hub's MCP server:

```kotlin
fun flintToMcpTools(app: FlintApp): List<McpTool> {
    val prefix = app.appLabel.lowercase().replace(" ", "_")

    // Global tools from the schema
    val appTools = app.schema.tools.map { tool ->
        McpTool(
            name = "$prefix.${tool.name}",
            description = "[${app.appLabel}] ${tool.description}",
            inputSchema = tool.inputSchema  // pass through, already JSON Schema
        )
    }

    // Standard Flint tools for every Flint app
    val flintTools = listOf(
        McpTool(
            name = "$prefix.read_screen",
            description = "[${app.appLabel}] Read current screen content as structured data"
        ),
        McpTool(
            name = "$prefix.get_screen",
            description = "[${app.appLabel}] Get the name of the current screen"
        ),
        McpTool(
            name = "$prefix.action",
            description = "[${app.appLabel}] Invoke a named action on a UI element",
            inputSchema = actionSchema  // { action, list?, index? }
        )
    )

    return appTools + flintTools
}
```

### Full MCP Tool List Seen by LLM

```
# Built-in device tools (Hub's own)
device.screenshot
device.tap
device.swipe
device.type
sms.send
notifications.list
apps.list
...

# From MusicApp (Flint-enabled)
musicapp.search               — global tool, navigates to search
musicapp.open_playlist         — global tool, navigates to playlist
musicapp.go_home               — global tool, navigates to home
musicapp.read_screen           — read current screen content
musicapp.get_screen            — get current screen name
musicapp.action                — invoke a named action

# From NotesApp (Flint-enabled)
notesapp.create_note           — global tool
notesapp.search_notes          — global tool
notesapp.read_screen
notesapp.get_screen
notesapp.action

# From BankApp (not Flint-enabled, no SDK)
# No app-specific tools, but Hub can still:
device.screenshot              — see what's on screen
device.tap                     — tap anything
device.get_tree                — read accessibility tree
apps.launch                    — open the bank app
```

---

## Part 8: End-to-End Flow Example

User asks the LLM: "Find Bohemian Rhapsody and play it."

```
Step 1: LLM sees musicapp.search is available
        Calls: musicapp.search({ query: "bohemian rhapsody" })

        Hub → contentResolver.call("content://com.musicapp.flint", "call_tool", "search", { query: "bohemian rhapsody" })
        App → MusicTools.search("bohemian rhapsody") runs
              navigator.navigate("search/bohemian rhapsody")
        Hub ← receives { _target: "search_results" }

Step 2: Hub polls musicapp.get_screen every 100ms
        After ~200ms, app reports: { screen: "search_results" }
        Confirmed: navigation landed.

Step 3: LLM calls musicapp.read_screen
        Hub → contentResolver.call(..., "read_screen", ...)
        SDK → walks semantic tree in app process
        Hub ← receives:
        {
          "screen": "search_results",
          "content": {
            "elements": [{
              "type": "list",
              "id": "results",
              "items": [
                {
                  "index": 0,
                  "content": { "title": "Bohemian Rhapsody", "artist": "Queen" },
                  "actions": [{ "name": "select", "description": "Select this track" }]
                },
                {
                  "index": 1,
                  "content": { "title": "Bohemian Like You", "artist": "Dandy Warhols" },
                  "actions": [{ "name": "select", "description": "Select this track" }]
                }
              ]
            }]
          },
          "overlays": []
        }

Step 4: LLM picks item 0 (Queen — Bohemian Rhapsody)
        Calls: musicapp.action({ action: "select", list: "results", index: 0 })
        OR: device.tap({ x: 540, y: 320 })  — accessibility fallback

        App navigates to track detail screen.
        Flint.screen("track_detail") fires.

Step 5: LLM calls musicapp.read_screen again
        Sees: screen = "track_detail"
        Content: { title: "Bohemian Rhapsody", artist: "Queen" }
        Actions: [{ name: "play" }, { name: "add_to_playlist" }, { name: "favorite" }]

Step 6: LLM sees "play" action available
        Calls: musicapp.action({ action: "play" })
        Music starts playing.

Step 7: LLM responds to user: "Playing Bohemian Rhapsody by Queen."
```

---

## Part 9: Complete Developer Integration Example

Here's everything a developer adds to make their music app Flint-enabled.

### `build.gradle.kts`

```kotlin
plugins {
    id("com.flintsdk") version "1.0.0"
}

dependencies {
    implementation("com.flintsdk:runtime:1.0.0")
    ksp("com.flintsdk:compiler:1.0.0")
}
```

### `MyApp.kt`

```kotlin
@HiltAndroidApp
class MyApp : Application() {
    @Inject lateinit var musicTools: MusicTools

    override fun onCreate() {
        super.onCreate()
        Flint.init(this)
        Flint.add(FlintRouter_MusicTools(musicTools))
    }
}
```

### `MusicTools.kt` (global tool handler)

```kotlin
@FlintToolHost
class MusicTools @Inject constructor(
    private val navigator: AppNavigator
) {
    @FlintTool(
        name = "search",
        description = "Search for tracks. Opens search results screen.",
        target = "search_results"
    )
    fun search(
        @FlintParam(description = "Search query") query: String
    ) {
        navigator.navigate("search/$query")
    }

    @FlintTool(
        name = "go_home",
        description = "Navigate to home screen.",
        target = "home"
    )
    fun goHome() {
        navigator.navigate("home")
    }
}
```

### `SearchResultsScreen.kt` (annotated UI)

```kotlin
@Composable
fun SearchResultsScreen(
    query: String,
    viewModel: SearchViewModel = hiltViewModel()
) {
    Flint.screen("search_results")

    val results by viewModel.results.collectAsState()

    Column {
        Text(
            text = "Results for \"$query\"",
            modifier = Modifier.flintContent("search_query")
        )

        LazyColumn(
            modifier = Modifier.flintList("results", "Search results for songs")
        ) {
            itemsIndexed(results) { index, track ->
                Row(
                    modifier = Modifier
                        .flintItem(index)
                        .flintAction("select", "Select this track")
                        .clickable { viewModel.onTrackClick(track) }
                ) {
                    Text(
                        text = track.title,
                        modifier = Modifier.flintContent("title")
                    )
                    Text(
                        text = track.artist,
                        modifier = Modifier.flintContent("artist")
                    )
                    IconButton(
                        onClick = { viewModel.toggleFavorite(track) },
                        modifier = Modifier.flintAction("favorite", "Toggle favorite")
                    ) {
                        Icon(Icons.Default.Favorite, "Favorite")
                    }
                }
            }
        }
    }
}
```

### `TrackDetailScreen.kt`

```kotlin
@Composable
fun TrackDetailScreen(
    trackId: String,
    viewModel: TrackDetailViewModel = hiltViewModel()
) {
    Flint.screen("track_detail")

    val track by viewModel.track.collectAsState()

    Column {
        Text(
            text = track.title,
            modifier = Modifier.flintContent("title")
        )
        Text(
            text = track.artist,
            modifier = Modifier.flintContent("artist")
        )
        Text(
            text = track.album,
            modifier = Modifier.flintContent("album")
        )

        Row {
            IconButton(
                onClick = { viewModel.play() },
                modifier = Modifier.flintAction("play", "Play this track")
            ) {
                Icon(Icons.Default.PlayArrow, "Play")
            }
            IconButton(
                onClick = { viewModel.addToPlaylist() },
                modifier = Modifier.flintAction("add_to_playlist", "Add to playlist")
            ) {
                Icon(Icons.Default.PlaylistAdd, "Add to playlist")
            }
        }
    }

    // Dialog overlay
    if (viewModel.showPlaylistPicker) {
        AlertDialog(
            modifier = Modifier.flintOverlay("playlist_picker", "Choose a playlist"),
            onDismissRequest = { viewModel.dismissPlaylistPicker() },
            text = {
                LazyColumn(
                    modifier = Modifier.flintList("playlists", "Available playlists")
                ) {
                    itemsIndexed(viewModel.playlists) { index, playlist ->
                        Text(
                            text = playlist.name,
                            modifier = Modifier
                                .flintItem(index)
                                .flintContent("name")
                                .flintAction("select_playlist", "Add track to this playlist")
                                .clickable { viewModel.addTo(playlist) }
                        )
                    }
                }
            },
            confirmButton = {}
        )
    }
}
```

### `MainScaffold.kt` (persistent overlay)

```kotlin
@Composable
fun MainScaffold(navController: NavHostController) {
    Scaffold(
        bottomBar = {
            MiniPlayerBar(
                modifier = Modifier.flintOverlay("player_mini", "Currently playing track")
            )
        }
    ) { padding ->
        NavHost(navController, startDestination = "home") {
            composable("home") { HomeScreen() }
            composable("search/{query}") { SearchResultsScreen(it.arguments?.getString("query") ?: "") }
            composable("track/{id}") { TrackDetailScreen(it.arguments?.getString("id") ?: "") }
        }
    }
}

@Composable
fun MiniPlayerBar(modifier: Modifier = Modifier) {
    Row(modifier = modifier) {
        Text(
            text = currentTrack.title,
            modifier = Modifier.flintContent("title")
        )
        Text(
            text = currentTrack.artist,
            modifier = Modifier.flintContent("artist")
        )
        IconButton(
            onClick = { togglePlayPause() },
            modifier = Modifier.flintAction("play_pause", "Play or pause")
        ) {
            Icon(if (isPlaying) Icons.Default.Pause else Icons.Default.PlayArrow, "Play/Pause")
        }
        IconButton(
            onClick = { nextTrack() },
            modifier = Modifier.flintAction("next", "Next track")
        ) {
            Icon(Icons.Default.SkipNext, "Next")
        }
    }
}
```

---

## Part 10: Progressive Enhancement

Developers can adopt Flint incrementally. More annotations = richer AI experience. Less annotations = still works via accessibility.

### Level 0: No SDK (any app)
Hub uses AccessibilityService. Reads raw accessibility tree, takes screenshots, taps by coordinates. Works for every app on the device. No developer action needed.

### Level 1: Tools + Screens Only
Developer adds SDK, defines global tools, adds `Flint.screen()` to composables. Hub can navigate the app and know which screen is showing. Screen reading falls back to accessibility tree.

### Level 2: Annotated Content
Developer adds `flintContent` to key UI elements. Hub gets structured data — field names and values instead of raw text nodes. LLM can reason about the data without parsing raw strings.

### Level 3: Annotated Actions
Developer adds `flintAction` to interactive elements. Hub can invoke actions by name instead of coordinate tapping. More reliable, survives layout changes.

### Level 4: Full Annotation
Developer adds `flintList`, `flintItem`, `flintOverlay` throughout. Hub gets a complete structured representation of the screen. LLM operates with full context — knows what's a list, what's an overlay, what actions are available on each item.

---

## Part 11: Security

| Concern | Solution |
|---|---|
| Unauthorized Hub access | ContentProvider can verify calling package signature |
| Rogue app pretending to be Hub | Apps can hardcode the Hub's signing certificate |
| Sensitive tools exposed | Developer chooses what to annotate — nothing is automatic |
| Network exposure | Hub's HTTP server requires token auth. Default localhost only. |
| Remote access | Recommend Tailscale for secure remote connections |
| Data in transit | Optional TLS on the HTTP/SSE server |

---

## Part 12: Distribution

### Hub App
- **Primary:** Google Play — frame as "AI accessibility assistant"
- **Fallback:** F-Droid, GitHub releases, direct APK
- AccessibilityService declaration required for Play Store

### Flint SDK
- **Maven Central** — standard Android library distribution
- No Play Store restrictions — it's just a library
- MIT licensed, fully open source

### Capability JSON
- Generated at build time by KSP
- Bundled inside the APK as `res/raw/flint.json`
- No runtime generation, no network dependency

---

## Summary

What the developer touches:

```
build.gradle.kts          — 3 lines (plugin + 2 dependencies)
MyApp.kt                  — 3 lines (init, add handler)
MyTools.kt                — annotated navigation methods
Each Screen Composable    — Flint.screen("name") + flintContent/flintAction/etc modifiers
```

What the developer doesn't touch:

```
MCP protocol              — Hub handles it
ContentProvider            — SDK auto-merges
JSON schema               — KSP generates it
Tool routing               — KSP generates it
Screen tree walking        — SDK handles it
Inter-process communication — SDK handles it
Accessibility integration  — SDK handles it (semantics modifiers)
```

What the LLM sees:

```
One MCP connection
All device tools
All Flint app tools
Structured screen snapshots
Named actions on UI elements
Clear navigation flow (tool → target screen → read → act)
```
